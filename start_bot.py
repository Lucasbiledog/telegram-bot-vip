#!/usr/bin/env python3
"""
Script de inicializa√ß√£o robusta do bot Telegram
Mant√©m o bot sempre ativo com auto-restart em caso de falhas
"""
import os
import sys
import time
import logging
import subprocess
import signal
from datetime import datetime

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('bot_supervisor.log', encoding='utf-8')
    ]
)

class BotSupervisor:
    def __init__(self):
        self.process = None
        self.restart_count = 0
        self.max_restarts = 10  # M√°ximo de reinicializa√ß√µes por hora
        self.restart_times = []
        self.running = True
        
    def cleanup_old_restarts(self):
        """Remove reinicializa√ß√µes antigas (mais de 1 hora)"""
        now = datetime.now()
        self.restart_times = [
            restart_time for restart_time in self.restart_times 
            if (now - restart_time).seconds < 3600  # 1 hora
        ]
    
    def can_restart(self):
        """Verifica se pode reiniciar (limite de reinicializa√ß√µes por hora)"""
        self.cleanup_old_restarts()
        return len(self.restart_times) < self.max_restarts
    
    def start_bot(self):
        """Inicia o processo do bot"""
        try:
            logging.info("üöÄ Iniciando bot Telegram...")
            self.process = subprocess.Popen(
                [sys.executable, "main.py"],
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1,
                universal_newlines=True
            )
            logging.info(f"‚úÖ Bot iniciado com PID: {self.process.pid}")
            return True
        except Exception as e:
            logging.error(f"‚ùå Erro ao iniciar bot: {e}")
            return False
    
    def monitor_bot(self):
        """Monitora o processo do bot"""
        if not self.process:
            return False
            
        # Verificar se o processo ainda est√° rodando
        return_code = self.process.poll()
        
        if return_code is None:
            # Processo ainda est√° rodando
            return True
        else:
            # Processo terminou
            logging.warning(f"üîÑ Bot terminou com c√≥digo: {return_code}")
            
            # Ler output restante
            try:
                output, _ = self.process.communicate(timeout=5)
                if output:
                    logging.info(f"Output final do bot: {output}")
            except subprocess.TimeoutExpired:
                self.process.kill()
                
            return False
    
    def restart_bot(self):
        """Reinicia o bot"""
        if not self.can_restart():
            logging.error("‚ùå Limite de reinicializa√ß√µes atingido por hora!")
            logging.error("‚è∞ Aguardando 1 hora antes de permitir novos restarts...")
            time.sleep(3600)  # Aguardar 1 hora
            return False
            
        logging.info("üîÑ Reiniciando bot em 5 segundos...")
        time.sleep(5)
        
        self.restart_times.append(datetime.now())
        self.restart_count += 1
        
        return self.start_bot()
    
    def signal_handler(self, signum, frame):
        """Handler para sinais de sistema"""
        logging.info(f"üì° Recebido sinal {signum}")
        if signum == signal.SIGINT:
            logging.info("üõë Ctrl+C detectado - parando supervisor...")
            self.running = False
            if self.process:
                self.process.terminate()
        elif signum == signal.SIGTERM:
            logging.info("üõë SIGTERM detectado - parando supervisor...")
            self.running = False
            if self.process:
                self.process.terminate()
    
    def run(self):
        """Execu√ß√£o principal do supervisor"""
        # Configurar handlers de sinal
        signal.signal(signal.SIGINT, self.signal_handler)
        if hasattr(signal, 'SIGTERM'):
            signal.signal(signal.SIGTERM, self.signal_handler)
        
        logging.info("ü§ñ Bot Supervisor iniciado!")
        logging.info("üì± Para parar completamente, use Ctrl+C duas vezes")
        logging.info("üîÑ O bot ser√° reiniciado automaticamente em caso de falha")
        
        # Iniciar o bot pela primeira vez
        if not self.start_bot():
            logging.error("‚ùå Falha ao iniciar bot inicial!")
            return
        
        # Loop de monitoramento
        while self.running:
            try:
                time.sleep(5)  # Verificar a cada 5 segundos
                
                if not self.monitor_bot():
                    if self.running:  # S√≥ reiniciar se n√£o foi interrompido intencionalmente
                        logging.warning("‚ö†Ô∏è Bot parou unexpectadamente!")
                        if not self.restart_bot():
                            logging.error("‚ùå Falha ao reiniciar bot!")
                            break
                
            except KeyboardInterrupt:
                logging.info("üõë Segunda interrup√ß√£o detectada - parando definitivamente...")
                self.running = False
                if self.process:
                    self.process.terminate()
                break
            except Exception as e:
                logging.error(f"‚ùå Erro no supervisor: {e}")
                time.sleep(10)
        
        logging.info("üîö Bot Supervisor finalizado")

if __name__ == "__main__":
    # Mudar para o diret√≥rio do script
    os.chdir(os.path.dirname(os.path.abspath(__file__)))
    
    supervisor = BotSupervisor()
    supervisor.run()