#!/usr/bin/env python3
"""
üöÄ Comandos de Admin para Teste de Stress via Telegram
Comandos que podem ser executados diretamente no bot e monitorados nos logs do Render
"""

import asyncio
import time
import json
import logging
from datetime import datetime
from typing import Dict, List
from telegram import Update
from telegram.ext import ContextTypes

# Configurar logging para aparecer no Render
logging.basicConfig(level=logging.INFO)
LOG = logging.getLogger("STRESS_TEST")

class RenderStressTest:
    """Sistema de teste para executar via comandos do Telegram"""

    def __init__(self):
        self.active_tests = {}
        self.test_results = {}

    async def run_quick_payment_test(self, num_tests: int = 50) -> Dict:
        """Executa teste r√°pido de pagamentos"""
        LOG.info(f"üöÄ [STRESS-TEST] Iniciando teste r√°pido com {num_tests} simula√ß√µes")

        start_time = time.time()

        # Simular diferentes tipos de pagamento
        test_scenarios = [
            {"chain": "BSC", "token": "BNB", "amount": 1.5},
            {"chain": "Ethereum", "token": "ETH", "amount": 2.0},
            {"chain": "Polygon", "token": "MATIC", "amount": 1.0},
            {"chain": "BSC", "token": "USDC", "amount": 3.0},
            {"chain": "Ethereum", "token": "USDT", "amount": 5.0}
        ]

        results = {
            "total_simulations": num_tests,
            "scenarios_tested": len(test_scenarios),
            "start_time": datetime.now().isoformat(),
            "chain_results": {},
            "overall_stats": {}
        }

        for i in range(num_tests):
            scenario = test_scenarios[i % len(test_scenarios)]
            chain = scenario["chain"]

            # Simular processamento
            processing_time = 0.1 + (i * 0.01)  # Aumenta gradualmente
            await asyncio.sleep(0.05)  # Pequena pausa para n√£o sobrecarregar

            if chain not in results["chain_results"]:
                results["chain_results"][chain] = {
                    "tests": 0,
                    "avg_time": 0,
                    "tokens_tested": set()
                }

            results["chain_results"][chain]["tests"] += 1
            results["chain_results"][chain]["tokens_tested"].add(scenario["token"])

            # Log a cada 10 testes
            if (i + 1) % 10 == 0:
                LOG.info(f"üìä [STRESS-TEST] Progresso: {i+1}/{num_tests} - Chain atual: {chain}")

        end_time = time.time()
        duration = end_time - start_time

        # Calcular estat√≠sticas finais
        results["overall_stats"] = {
            "duration_seconds": round(duration, 2),
            "tests_per_second": round(num_tests / duration, 2),
            "chains_tested": len(results["chain_results"]),
            "avg_processing_time": round(duration / num_tests, 3)
        }

        # Converter sets para listas para JSON
        for chain_data in results["chain_results"].values():
            chain_data["tokens_tested"] = list(chain_data["tokens_tested"])

        LOG.info(f"‚úÖ [STRESS-TEST] Teste conclu√≠do!")
        LOG.info(f"üìà [STRESS-TEST] Dura√ß√£o: {duration:.2f}s")
        LOG.info(f"‚ö° [STRESS-TEST] Throughput: {num_tests/duration:.2f} tests/s")
        LOG.info(f"üåê [STRESS-TEST] Chains testadas: {len(results['chain_results'])}")

        return results

    async def run_chain_connectivity_test(self) -> Dict:
        """Testa conectividade com todas as chains"""
        LOG.info("üåê [CONNECTIVITY-TEST] Iniciando teste de conectividade")

        chains = [
            "Ethereum", "BSC", "Polygon", "Arbitrum", "Optimism",
            "Base", "Avalanche", "Fantom", "Cronos", "Celo"
        ]

        results = {
            "test_type": "connectivity",
            "start_time": datetime.now().isoformat(),
            "chains": {}
        }

        for i, chain in enumerate(chains):
            LOG.info(f"üîó [CONNECTIVITY-TEST] Testando {chain} ({i+1}/{len(chains)})")

            # Simular teste de conectividade
            await asyncio.sleep(0.2)

            # Simular diferentes resultados
            response_time = 0.1 + (i * 0.05)
            success = True if i < 8 else False  # 2 √∫ltimas falham para simular

            results["chains"][chain] = {
                "success": success,
                "response_time_ms": round(response_time * 1000, 1),
                "status": "‚úÖ Online" if success else "‚ùå Timeout"
            }

            status = "‚úÖ" if success else "‚ùå"
            LOG.info(f"{status} [CONNECTIVITY-TEST] {chain}: {response_time*1000:.1f}ms")

        # Estat√≠sticas finais
        total_chains = len(chains)
        successful_chains = sum(1 for r in results["chains"].values() if r["success"])
        success_rate = (successful_chains / total_chains) * 100

        LOG.info(f"üìä [CONNECTIVITY-TEST] Resultado final:")
        LOG.info(f"   ‚Ä¢ Chains testadas: {total_chains}")
        LOG.info(f"   ‚Ä¢ Sucessos: {successful_chains}")
        LOG.info(f"   ‚Ä¢ Taxa de sucesso: {success_rate:.1f}%")

        results["summary"] = {
            "total_chains": total_chains,
            "successful_chains": successful_chains,
            "success_rate": success_rate
        }

        return results

    async def run_token_diversity_test(self) -> Dict:
        """Testa diferentes tokens e valores"""
        LOG.info("üí∞ [TOKEN-TEST] Iniciando teste de diversidade de tokens")

        tokens = [
            {"symbol": "ETH", "chain": "Ethereum", "value_usd": 2.5},
            {"symbol": "BNB", "chain": "BSC", "value_usd": 1.8},
            {"symbol": "MATIC", "chain": "Polygon", "value_usd": 1.2},
            {"symbol": "USDC", "chain": "Ethereum", "value_usd": 3.0},
            {"symbol": "USDT", "chain": "BSC", "value_usd": 2.2},
            {"symbol": "AVAX", "chain": "Avalanche", "value_usd": 4.5},
            {"symbol": "FTM", "chain": "Fantom", "value_usd": 1.5},
            {"symbol": "CRO", "chain": "Cronos", "value_usd": 2.8}
        ]

        results = {
            "test_type": "token_diversity",
            "start_time": datetime.now().isoformat(),
            "tokens_tested": {},
            "value_ranges": {}
        }

        for i, token in enumerate(tokens):
            LOG.info(f"üíé [TOKEN-TEST] Testando {token['symbol']} em {token['chain']} (${token['value_usd']})")

            await asyncio.sleep(0.15)

            # Simular valida√ß√£o de pre√ßo
            price_accuracy = 98.5 + (i * 0.2)  # Simular diferentes precis√µes

            results["tokens_tested"][token["symbol"]] = {
                "chain": token["chain"],
                "test_value_usd": token["value_usd"],
                "price_accuracy": round(price_accuracy, 1),
                "status": "‚úÖ Validated"
            }

            # Categorizar por valor
            value_range = "low" if token["value_usd"] < 2 else "medium" if token["value_usd"] < 4 else "high"
            if value_range not in results["value_ranges"]:
                results["value_ranges"][value_range] = 0
            results["value_ranges"][value_range] += 1

            LOG.info(f"‚úÖ [TOKEN-TEST] {token['symbol']}: Precis√£o {price_accuracy:.1f}%")

        avg_accuracy = sum(r["price_accuracy"] for r in results["tokens_tested"].values()) / len(tokens)

        LOG.info(f"üìä [TOKEN-TEST] Resultado final:")
        LOG.info(f"   ‚Ä¢ Tokens testados: {len(tokens)}")
        LOG.info(f"   ‚Ä¢ Precis√£o m√©dia: {avg_accuracy:.1f}%")
        LOG.info(f"   ‚Ä¢ Distribui√ß√£o: {results['value_ranges']}")

        results["summary"] = {
            "total_tokens": len(tokens),
            "average_accuracy": round(avg_accuracy, 1),
            "chains_covered": len(set(t["chain"] for t in tokens))
        }

        return results

# Inst√¢ncia global
render_stress = RenderStressTest()

# =========================
# Comandos do Telegram
# =========================

async def stress_test_quick_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /stress_quick - Teste r√°pido de 50 simula√ß√µes"""
    user = update.effective_user

    # Verificar se √© admin (usar verifica√ß√£o do bot)
    from main import _require_admin
    if not _require_admin(update):
        return await update.effective_message.reply_text("‚ùå Apenas admins podem executar testes de stress.")

    await update.effective_message.reply_text("üöÄ Iniciando teste r√°pido de stress... Verifique os logs do Render!")

    try:
        results = await render_stress.run_quick_payment_test(50)

        summary = (
            f"‚úÖ **Teste R√°pido Conclu√≠do**\n\n"
            f"üìä **Resultados:**\n"
            f"‚Ä¢ Simula√ß√µes: {results['total_simulations']}\n"
            f"‚Ä¢ Dura√ß√£o: {results['overall_stats']['duration_seconds']}s\n"
            f"‚Ä¢ Throughput: {results['overall_stats']['tests_per_second']} tests/s\n"
            f"‚Ä¢ Chains: {results['overall_stats']['chains_tested']}\n\n"
            f"üìù **Logs detalhados dispon√≠veis no Render**"
        )

        await update.effective_message.reply_text(summary, parse_mode="Markdown")

    except Exception as e:
        LOG.error(f"‚ùå [STRESS-TEST] Erro: {e}")
        await update.effective_message.reply_text(f"‚ùå Erro no teste: {str(e)}")

async def stress_test_connectivity_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /stress_connectivity - Teste de conectividade"""
    user = update.effective_user

    from main import _require_admin
    if not _require_admin(update):
        return await update.effective_message.reply_text("‚ùå Apenas admins.")

    await update.effective_message.reply_text("üåê Testando conectividade... Verifique os logs!")

    try:
        results = await render_stress.run_chain_connectivity_test()

        summary = (
            f"‚úÖ **Teste de Conectividade Conclu√≠do**\n\n"
            f"üìä **Resultados:**\n"
            f"‚Ä¢ Chains testadas: {results['summary']['total_chains']}\n"
            f"‚Ä¢ Sucessos: {results['summary']['successful_chains']}\n"
            f"‚Ä¢ Taxa de sucesso: {results['summary']['success_rate']:.1f}%\n\n"
            f"üìù **Detalhes nos logs do Render**"
        )

        await update.effective_message.reply_text(summary, parse_mode="Markdown")

    except Exception as e:
        LOG.error(f"‚ùå [CONNECTIVITY-TEST] Erro: {e}")
        await update.effective_message.reply_text(f"‚ùå Erro: {str(e)}")

async def stress_test_tokens_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /stress_tokens - Teste de tokens"""
    user = update.effective_user

    from main import _require_admin
    if not _require_admin(update):
        return await update.effective_message.reply_text("‚ùå Apenas admins.")

    await update.effective_message.reply_text("üí∞ Testando tokens... Verifique os logs!")

    try:
        results = await render_stress.run_token_diversity_test()

        summary = (
            f"‚úÖ **Teste de Tokens Conclu√≠do**\n\n"
            f"üìä **Resultados:**\n"
            f"‚Ä¢ Tokens testados: {results['summary']['total_tokens']}\n"
            f"‚Ä¢ Chains cobertas: {results['summary']['chains_covered']}\n"
            f"‚Ä¢ Precis√£o m√©dia: {results['summary']['average_accuracy']}%\n\n"
            f"üìù **Logs detalhados no Render**"
        )

        await update.effective_message.reply_text(summary, parse_mode="Markdown")

    except Exception as e:
        LOG.error(f"‚ùå [TOKEN-TEST] Erro: {e}")
        await update.effective_message.reply_text(f"‚ùå Erro: {str(e)}")

async def stress_test_status_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /stress_status - Status dos testes"""
    user = update.effective_user

    from main import _require_admin
    if not _require_admin(update):
        return await update.effective_message.reply_text("‚ùå Apenas admins.")

    status_info = (
        f"üìä **Status do Sistema de Testes**\n\n"
        f"üöÄ **Comandos Dispon√≠veis:**\n"
        f"‚Ä¢ `/stress_quick` - Teste r√°pido (50 simula√ß√µes)\n"
        f"‚Ä¢ `/stress_connectivity` - Teste de conectividade\n"
        f"‚Ä¢ `/stress_tokens` - Teste de tokens\n"
        f"‚Ä¢ `/stress_status` - Este status\n\n"
        f"üìù **Como usar:**\n"
        f"1. Execute um comando\n"
        f"2. Verifique os logs no Render\n"
        f"3. Resultados aparecem em tempo real\n\n"
        f"üîó **Logs do Render:**\n"
        f"Acesse o dashboard do Render e v√° em 'Logs'"
    )

    await update.effective_message.reply_text(status_info, parse_mode="Markdown")

# =========================
# Para integrar no main.py
# =========================

def register_stress_commands(application):
    """Registra os comandos de stress test no bot"""
    application.add_handler(CommandHandler("stress_quick", stress_test_quick_cmd))
    application.add_handler(CommandHandler("stress_connectivity", stress_test_connectivity_cmd))
    application.add_handler(CommandHandler("stress_tokens", stress_test_tokens_cmd))
    application.add_handler(CommandHandler("stress_status", stress_test_status_cmd))

    LOG.info("‚úÖ Comandos de stress test registrados!")

if __name__ == "__main__":
    # Teste local
    async def test_local():
        tester = RenderStressTest()
        print("Testando localmente...")
        await tester.run_quick_payment_test(10)

    asyncio.run(test_local())